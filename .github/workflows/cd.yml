name: CD - Release DMG

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: true
        type: string

env:
  APP_NAME: RingBreak
  SCHEME: RingBreak
  PROJECT: RingBreak.xcodeproj

permissions:
  contents: write

jobs:
  build-and-release:
    name: Build, Sign, and Release DMG
    runs-on: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0  # Full history needed for release notes generation

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Show Xcode version
        run: xcodebuild -version

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Strip leading 'v' if user included it
            VERSION="${{ inputs.version }}"
            VERSION="${VERSION#v}"
          else
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Create tag for manual dispatch
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TAG="v${{ steps.version.outputs.version }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
          fi

      - name: Install Apple certificate and provisioning profile
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Import certificate from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      - name: Set version from tag
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          sed -i '' "s/MARKETING_VERSION = [^;]*;/MARKETING_VERSION = ${VERSION};/g" \
            "${PROJECT}/project.pbxproj"
          echo "Set MARKETING_VERSION to ${VERSION}"

      - name: Build Release
        env:
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
          CODE_SIGN_IDENTITY: ${{ secrets.CODE_SIGN_IDENTITY }}
        run: |
          # Create build directory
          mkdir -p build/Release

          # Build the app with code signing
          # CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO prevents the debug entitlement
          # (com.apple.security.get-task-allow) from being added, which would
          # cause notarization to fail
          xcodebuild build \
            -project $PROJECT \
            -target $APP_NAME \
            -configuration Release \
            -destination 'platform=macOS' \
            SYMROOT="$(pwd)/build" \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            OTHER_CODE_SIGN_FLAGS="--timestamp --options runtime"

      - name: Re-sign Sparkle framework for notarization
        env:
          CODE_SIGN_IDENTITY: ${{ secrets.CODE_SIGN_IDENTITY }}
        run: |
          SPARKLE_FRAMEWORK="build/Release/${APP_NAME}.app/Contents/Frameworks/Sparkle.framework"

          # Re-sign all nested binaries with Developer ID and secure timestamp
          find "$SPARKLE_FRAMEWORK" -type f \( -name "Autoupdate" -o -name "Downloader" -o -name "Installer" -o -name "Updater" \) | while read binary; do
            echo "Signing: $binary"
            codesign --force --sign "$CODE_SIGN_IDENTITY" --timestamp --options runtime "$binary"
          done

          # Re-sign XPC services
          find "$SPARKLE_FRAMEWORK" -name "*.xpc" -type d | while read xpc; do
            echo "Signing XPC: $xpc"
            codesign --force --sign "$CODE_SIGN_IDENTITY" --timestamp --options runtime "$xpc"
          done

          # Re-sign the framework itself
          codesign --force --sign "$CODE_SIGN_IDENTITY" --timestamp --options runtime "$SPARKLE_FRAMEWORK"

          # Re-sign the main app to update its seal
          codesign --force --sign "$CODE_SIGN_IDENTITY" --timestamp --options runtime --entitlements RingBreak/RingBreak.entitlements "build/Release/${APP_NAME}.app"

      - name: Verify code signature
        run: |
          codesign --verify --deep --strict "build/Release/${APP_NAME}.app"
          codesign -dv --verbose=4 "build/Release/${APP_NAME}.app"

      - name: Create DMG
        run: |
          chmod +x scripts/create-dmg.sh
          ./scripts/create-dmg.sh "build/Release/${APP_NAME}.app"

      - name: Notarize DMG
        id: notarize
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Submit for notarization and capture output
          SUBMIT_OUTPUT=$(xcrun notarytool submit "build/${APP_NAME}.dmg" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -E "^\s*id:" | head -1 | awk '{print $2}')
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT

          # Check if notarization succeeded
          if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization successful!"
            xcrun stapler staple "build/${APP_NAME}.dmg"
          else
            echo "::error::Notarization failed. Fetching detailed log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID"
            exit 1
          fi

      - name: Verify notarization
        run: |
          # Verify DMG notarization ticket is stapled
          xcrun stapler validate "build/${APP_NAME}.dmg"

          # Mount DMG and verify the app inside passes Gatekeeper
          hdiutil attach "build/${APP_NAME}.dmg" -nobrowse -quiet
          spctl -a -vv "/Volumes/Ring Break/${APP_NAME}.app"
          hdiutil detach "/Volumes/Ring Break" -quiet

      - name: Rename DMG with version
        run: |
          mv "build/${APP_NAME}.dmg" "build/${APP_NAME}-${{ steps.version.outputs.version }}.dmg"

      - name: Download Sparkle tools
        run: |
          curl -L -o /tmp/sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz"
          mkdir -p /tmp/sparkle
          tar -xf /tmp/sparkle.tar.xz -C /tmp/sparkle

      - name: Sign DMG for Sparkle updates
        id: sparkle_sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          DMG_PATH="build/${APP_NAME}-${{ steps.version.outputs.version }}.dmg"
          # sign_update outputs: sparkle:edSignature=BASE64 length=SIZE
          # Extract just the base64 signature
          FULL_OUTPUT=$(/tmp/sparkle/bin/sign_update "$DMG_PATH" --ed-key-file <(echo -n "$SPARKLE_PRIVATE_KEY"))
          SIGNATURE=$(echo "$FULL_OUTPUT" | sed 's/sparkle:edSignature=\([^ ]*\).*/\1/')
          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT
          echo "Sparkle signature generated: $SIGNATURE"

      - name: Generate appcast.xml
        run: |
          chmod +x scripts/generate-appcast.sh
          ./scripts/generate-appcast.sh \
            "${{ steps.version.outputs.version }}" \
            "build/${APP_NAME}-${{ steps.version.outputs.version }}.dmg" \
            "${{ steps.sparkle_sign.outputs.signature }}"

      - name: Publish appcast.xml
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Save appcast.xml before switching branches
          cp appcast.xml /tmp/appcast.xml

          # Create or update the appcast branch (unprotected)
          git checkout --orphan appcast-temp
          git rm -rf . || true
          cp /tmp/appcast.xml appcast.xml
          git add appcast.xml
          git commit -m "Update appcast.xml for v${{ steps.version.outputs.version }}"
          git push origin appcast-temp:appcast --force

      - name: Generate release notes
        id: release_notes
        run: |
          # Get commits since last tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s" $PREVIOUS_TAG..HEAD)
          else
            COMMITS=$(git log --pretty=format:"- %s" -10)
          fi

          # Write to file for multiline support
          cat << EOF > release_notes.md
          ## What's New in v${{ steps.version.outputs.version }}

          $COMMITS

          ---

          ### Installation

          1. Download \`${APP_NAME}-${{ steps.version.outputs.version }}.dmg\`
          2. Open the DMG file
          3. Drag Ring Break to your Applications folder
          4. Launch Ring Break from Applications

          ### Requirements

          - macOS 14.0 (Sonoma) or later
          - Nintendo Joy-Con (R) controller
          - Nintendo Ring-Con accessory
          - Bluetooth connectivity
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2.5.0
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Ring Break v${{ steps.version.outputs.version }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          files: |
            build/${{ env.APP_NAME }}-${{ steps.version.outputs.version }}.dmg
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
